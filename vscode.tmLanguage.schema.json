{
	"$schema": "http://json-schema.org/draft-07/schema#",
	"$id": "https://raw.githubusercontent.com/RedCMD/TmLanguage-Syntax-Highlighter/main/vscode.tmLanguage.schema.json",
	"title": "VSCode JSON TextMate",
	"$comment": "https://opis.io/json-schema/2.x/",
	"allowComments": false,
	"allowTrailingCommas": false,
	"$ref": "#/definitions/root",
	"definitions": {
		"root": {
			"markdownDescription": "[Documentation](https://github.com/RedCMD/TmLanguage-Syntax-Highlighter/blob/main/documentation/index.md) | [Schema](https://github.com/RedCMD/TmLanguage-Syntax-Highlighter/blob/main/vscode.tmLanguage.schema.json)",
			"type": "object",
			"required": [
				"scopeName",
				"patterns"
			],
			"properties": {
				"version": {
					"description": "A link to the current version of the file",
					"type": "string",
					"suggestSortText": "~version"
				},
				"$schema": {
					"description": "The Schema used to validate this file",
					"type": "string",
					"default": "https://raw.githubusercontent.com/RedCMD/TmLanguage-Syntax-Highlighter/main/vscode.tmLanguage.schema.json"
				},
				"name": {
					"description": "The name of your language",
					"type": "string",
					"suggestSortText": "@name"
				},
				"scopeName": {
					"markdownDescription": "The `scope-name` for your language  \nIt is the same value as `\"scopeName\"` under `\"grammars\"` in your `package.json` file",
					"type": "string",
					"pattern": "^(source|text|markdown|html)(\\.[\\w-]+)*$",
					"suggestSortText": "!!scopeName"
				},
				"comment": { "$ref": "#/definitions/comment" },
				"//": { "$ref": "#/definitions/commentSlash" },
				"patterns": {
					"$ref": "#/definitions/patterns",
					"suggestSortText": "!patterns"
				},
				"repository": {
					"$ref": "#/definitions/repository",
					"suggestSortText": "@repository"
				},
				"injections": {
					"description": "A dictionary of injections. They do NOT work when the grammar is embedded into another language",
					"type": "object",
					"additionalProperties": {
						"description": "An injection selector. https://code.visualstudio.com/api/language-extensions/syntax-highlight-guide#injection-grammars",
						"type": "object",
						"properties": {
							"patterns": {
								"$ref": "#/definitions/patterns",
								"suggestSortText": "@patterns"
							},
							"comment": { "$ref": "#/definitions/comment" },
							"//": { "$ref": "#/definitions/commentSlash" }
						},
						"additionalProperties": { "description": "Unknown key" }
					},
					"default": { "L:source.scopeName -comment -string, R:source.scopeName.another": { } }
				},
				"injectionSelector": {
					"markdownDescription": "Controls which scope-names to inject the grammar into and with what priority. Default is 0, L: is -1 and R: is 1  \nUsed in conjunction with `\"injectTo\"` under `\"grammars\"` in your `package.json` file  \nhttps://code.visualstudio.com/api/language-extensions/syntax-highlight-guide#injection-grammars",
					"$ref": "#/definitions/injectionSelector"
				},
				"fileTypes": {
					"markdownDescription": "An array of file extensions your language supports  \n_Not currently supported by VSCode_  \nUse `\"extensions\"` under `\"languages\"` in your `package.json` file instead",
					"type": "array",
					"uniqueItems": true,
					"items": {
						"type": "string",
						"pattern": "^[\\w.-]+$"
					},
					"suggestSortText": "~fileTypes"
				},
				"firstLineMatch": {
					"markdownDescription": "A regex to detect if an open file should get assigned to your language  \n_Not currently supported by VSCode_  \nUse `\"firstLine\"` under `\"languages\"` in your `package.json` file instead",
					"type": "string",
					"format": "regex",
					"suggestSortText": "~firstLineMatch"
				},
				"foldingStartMarker": {
					"markdownDescription": "A regex to define the start of a folding section  \n_Not currently supported by VSCode_  \nUse `\"folding\"` in your `language-configuration.json` file instead",
					"type": "string",
					"format": "regex",
					"pattern": "\\^|\\$",
					"suggestSortText": "~foldingStartMarker"
				},
				"foldingStopMarker": {
					"markdownDescription": "A regex to define the end of the folding section  \n_Not currently supported by VSCode_  \nUse `\"folding\"` in your `language-configuration.json` file instead",
					"type": "string",
					"format": "regex",
					"pattern": "\\^|\\$",
					"suggestSortText": "~foldingStopMarker"
				},
				"uuid": {
					"$comment": "Technically this should be required in all json files",
					"description": "A Universally Unique IDentifier for this json file",
					"type": "string",
					"format": "uuid",
					"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
					"suggestSortText": "~uuid"
				}
			},
			"additionalProperties": { "description": "Unknown key" },
			"dependencies": { "foldingStopMarker": { "required": [ "foldingStartMarker" ] } },
			"defaultSnippets": [
				{
					"label": "New Grammar",
					"markdownDescription": "\t{\n\t\t\"scopeName\": \"source.languageId\",\n\t\t\"patterns\": [\n\t\t\t{ ... }\n\t\t],\n\t\t\"repository\": { ... }\n\t}\n\n\t/* package.json */\n\t\"grammars\": [\n\t\t{\n\t\t\t\"language\": \"languageId\",\n\t\t\t\"scopeName\": \"source.languageId\",\n\t\t\t\"path\": \"./syntaxes/languageId.tmLanguage.json\",\n\t\t}\n\t]\n",
					"body": {
						"$${_///}schema": "https://raw.githubusercontent.com/RedCMD/TmLanguage-Syntax-Highlighter/main/vscode.tmLanguage.schema.json",
						"name": "${1/([._-]+)|([a-zA-Z]+)/${1:+ }${2:/capitalize}/g}",
						"scopeName": "source.${1:languageId}",
						"patterns": [
							"^{ \"include\": \"#${2:repo-item}\" }",
							"^{ \"include\": \"#string\" }",
							"^{ \"include\": \"#boolean\" }"
						],
						"repository": {
							"${2:repo-item}": "^{\n\t\t\t$0\n\t\t}",
							"boolean": {
								"comment": "^\"`\\\\\\\\b` is a 0-width word boundary. `\\$1` references capture group 1\"",
								"match": "\\\\b(true|false)\\\\b",
								"name": "^\"constant.language.\\$1.${1:languageId}\""
							},
							"string": {
								"comment": "\"begin\" & \"end\" can create a multi-line region",
								"begin": "\"",
								"end": "\"",
								"beginCaptures": "^{ \"0\": { \"name\": \"punctuation.definition.string.begin.${1:languageId}\" } }",
								"endCaptures": "^{ \"0\": { \"name\": \"punctuation.definition.string.end.${1:languageId}\" } }",
								"name": "string.quoted.double.${1:languageId}",
								"patterns": [
									{
										"comment": "Quad backslash required to match one literal backslash",
										"match": "\\\\\\\\.",
										"name": "constant.character.escape.${1:languageId}"
									}
								]
							}
						}
					}
				},
				{
					"label": "New Markdown Code-Block Injection",
					"markdownDescription": "\t{\n\t\t\"name\": \"Markdown Code-Block Injection languageId\",\n\t\t\"scopeName\": \"markdown.languageId.codeblock\",\n\t\t\"injectionSelector\": \"L:text.html.markdown\",\n\t\t\"patterns\": [\n\t\t\t{ \"include\": \"#fenced_code_block_languageId\" }\n\t\t],\n\t\t\"repository\": {\n\t\t\t\"fenced_code_block_languageId\": { ... }\n\t\t}\n\t}\n\n\t/* package.json */\n\t\"grammars\": [\n\t\t{\n\t\t\t\"scopeName\": \"markdown.languageId.codeblock\",\n\t\t\t\"path\": \"./syntaxes/languageId.tmLanguage.json\",\n\t\t\t\"injectTo\": [\n\t\t\t\t\"text.html.markdown\"\n\t\t\t],\n\t\t\t\"embeddedLanguages\": {\n\t\t\t\t\"meta.embedded.block.languageId\": \"languageId\"\n\t\t\t}\n\t\t}\n\t]",
					"body": {
						"$${_///}schema": "https://raw.githubusercontent.com/RedCMD/TmLanguage-Syntax-Highlighter/main/vscode.tmLanguage.schema.json",
						"comment": "https://github.com/mjbvz/vscode-fenced-code-block-grammar-injection-example/blob/master/syntaxes/codeblock.json",
						"name": "Markdown Code-Block Injection ${1/([._-]+)|([a-zA-Z]+)/${1:+ }${2:/capitalize}/g}$0",
						"scopeName": "markdown.${1:languageId}.codeblock",
						"injectionSelector": "L:text.html.markdown -meta.embedded.block.${1:languageId}",
						"patterns": [
							"^{ \"include\": \"#fenced_code_block_${1/[. -]/_/g}\" }"
						],
						"repository": {
							"fenced_code_block_${1/[. -]/_/g}": {
								"begin": "(^|\\\\G)(\\\\s*)(\\\\`{3,}|~{3,})\\\\s*(?i:(${1/([.+])/\\\\$1/g})((\\\\s+|:|,|\\\\{|\\\\?)[^`]*)?$)",
								"name": "markup.fenced_code.block.markdown",
								"end": "(^|\\\\G)(\\\\2|\\\\s{0,3})(\\\\3)\\\\s*$",
								"beginCaptures": {
									"3": "^{ \"name\": \"punctuation.definition.markdown\" }",
									"4": "^{ \"name\": \"fenced_code.block.language.markdown\" }",
									"5": "^{ \"name\": \"fenced_code.block.language.attributes.markdown\" }"
								},
								"endCaptures": "^{ \"3\": { \"name\": \"punctuation.definition.markdown\" } }",
								"patterns": [
									{
										"begin": "(^|\\\\G)(\\\\s*)(.*)",
										"while": "(^|\\\\G)(?!\\\\s*([`~]{3,})\\\\s*$)",
										"contentName": "meta.embedded.block.${1:languageId}",
										"patterns": "^[ { \"include\": \"source.${1:languageId}\" } ]"
									}
								]
							}
						}
					}
				},
				{
					"label": "New Search Results Injection",
					"markdownDescription": "\t{\n\t\t\"name\": \"Search Results Injection languageId\",\n\t\t\"scopeName\": \"text.searchResult.languageId\",\n\t\t\"injectionSelector\": \"L:text.searchResult\",\n\t\t\"patterns\": [\n\t\t\t{ \"include\": \"#languageId\" }\n\t\t],\n\t\t\"repository\": {\n\t\t\t\"languageId\": { ... }\n\t\t}\n\t}\n\n\t/* package.json */\n\t\"grammars\": [\n\t\t{\n\t\t\t\"scopeName\": \"text.searchResult.languageId\",\n\t\t\t\"path\": \"./syntaxes/languageId.tmLanguage.json\",\n\t\t\t\"injectTo\": [\n\t\t\t\t\"text.searchResult\"\n\t\t\t]\n\t\t}\n\t]",
					"body": {
						"$${_///}schema": "https://raw.githubusercontent.com/RedCMD/TmLanguage-Syntax-Highlighter/main/vscode.tmLanguage.schema.json",
						"comment": "https://github.com/microsoft/vscode/issues/185430",
						"name": "Search Results Injection ${1/([._-]+)|([a-zA-Z]+)/${1:+ }${2:/capitalize}/g}$0",
						"scopeName": "text.searchResult.${1:languageId}",
						"injectionSelector": "L:text.searchResult -meta.resultBlock.search",
						"patterns": [
							"^{ \"include\": \"#${1/[. -]/_/g}\" }"
						],
						"repository": {
							"${1/[. -]/_/g}": {
								"name": "meta.resultBlock.search",
								"begin": "${_///}^(?!\\\\s)(.*?)([^\\\\\\\\\\\\/\\\\n]*\\\\.${1/([.+])/\\\\$1/g})(:)$",
								"end": "${_///}^(?!\\\\s)",
								"beginCaptures": {
									"0": "^{ \"name\": \"string meta.path.search\" }",
									"1": "^{ \"name\": \"meta.path.dirname.search\" }",
									"2": "^{ \"name\": \"meta.path.basename.search\" }",
									"3": "^{ \"name\": \"punctuation.separator\" }"
								},
								"patterns": [
									{
										"name": "meta.resultLine.search meta.resultLine.multiLine.search",
										"begin": "${_///}^  (?:\\\\s*)((\\\\d+) )",
										"while": "${_///}^  (?:\\\\s*)(?:((\\\\d+)(:))|((\\\\d+) ))",
										"beginCaptures": {
											"0": "^{ \"name\": \"constant.numeric.integer meta.resultLinePrefix.search\" }",
											"1": "^{ \"name\": \"meta.resultLinePrefix.contextLinePrefix.search\" }",
											"2": "^{ \"name\": \"meta.resultLinePrefix.lineNumber.search\" }"
										},
										"whileCaptures": {
											"0": "^{ \"name\": \"constant.numeric.integer meta.resultLinePrefix.search\" }",
											"1": "^{ \"name\": \"meta.resultLinePrefix.matchLinePrefix.search\" }",
											"2": "^{ \"name\": \"meta.resultLinePrefix.lineNumber.search\" }",
											"3": "^{ \"name\": \"punctuation.separator\" }",
											"4": "^{ \"name\": \"meta.resultLinePrefix.contextLinePrefix.search\" }",
											"5": "^{ \"name\": \"meta.resultLinePrefix.lineNumber.search\" }"
										},
										"patterns": "^[ { \"include\": \"source.${1:languageId}\" } ]"
									},
									{
										"begin": "${_///}^  (?:\\\\s*)((\\\\d+)(:))",
										"while": "(?=not)possible",
										"name": "meta.resultLine.search meta.resultLine.singleLine.search",
										"beginCaptures": {
											"0": "^{ \"name\": \"constant.numeric.integer meta.resultLinePrefix.search\" }",
											"1": "^{ \"name\": \"meta.resultLinePrefix.matchLinePrefix.search\" }",
											"2": "^{ \"name\": \"meta.resultLinePrefix.lineNumber.search\" }",
											"3": "^{ \"name\": \"punctuation.separator\" }"
										},
										"patterns": "^[ { \"include\": \"source.${1:languageId}\" } ]"
									}
								]
							}
						}
					}
				}
			]
		},
		"repository": {
			"description": "A dictionary of rules\nhttps://code.visualstudio.com/api/language-extensions/syntax-highlight-guide#contributing-a-basic-grammar",
			"type": "object",
			"properties": {
				"repo-item": {
					"markdownDescription": "A repository item. Reference using `\"include\": \"#repo-item\"`",
					"$ref": "#/definitions/repo"
				},
				"$self": {
					"description": "Internal VSCode TextMate node. Is overridden at parse time",
					"$ref": "#/definitions/repo",
					"doNotSuggest": true
				},
				"$base": {
					"description": "Internal VSCode TextMate node. Is overridden at parse time",
					"$ref": "#/definitions/repo",
					"doNotSuggest": true
				}
			},
			"additionalProperties": {
				"markdownDescription": "A repository item. Reference using `\"include\": \"#...\"`",
				"$ref": "#/definitions/repo"
			},
			"defaultSnippets": [
				{
					"label": "Repo-item",
					"markdownDescription": "\t\"repository\": {\n\t\t\"repo-item\": {\n\n\t\t}\n\t}",
					"body": { "${1:repo-item}": { } }
				}
			]
		},
		"repo": {
			"allOf": [
				{
					"dependencies": {
						"repository": {
							"anyOf": [
								{ "required": [ "patterns" ] },
								{
									"required": [ "include" ],
									"properties": {
										"include": {
											"$ref": "#/definitions/include",
											"suggestSortText": "@include"
										}
									}
								}
							]
						}
					}
				},
				{ "$ref": "#/definitions/pattern" }
			],
			"default": { }
		},
		"patterns": {
			"description": "An array of pattern's to include",
			"type": "array",
			"items": {
				"$comment": "many warnings :)",
				"type": [ "object" ],
				"not": {
					"type": [
						"string",
						"boolean",
						"integer",
						"number",
						"null"
					]
				},
				"allOf": [
					{
						"dependencies": {
							"repository": {
								"required": [ "patterns" ],
								"properties": {
									"include": {
										"$ref": "#/definitions/include",
										"suggestSortText": "~include"
									}
								}
							}
						}
					},
					{ "$ref": "#/definitions/pattern" }
				]
			}
		},
		"pattern": {
			"type": "object",
			"properties": {
				"match": { "$ref": "#/definitions/match" },
				"begin": { "$ref": "#/definitions/begin" },
				"end": { "$ref": "#/definitions/end" },
				"while": { "$ref": "#/definitions/while" },
				"captures": { "$ref": "#/definitions/captures" },
				"beginCaptures": { "$ref": "#/definitions/beginCaptures" },
				"endCaptures": { "$ref": "#/definitions/endCaptures" },
				"whileCaptures": { "$ref": "#/definitions/whileCaptures" },
				"applyEndPatternLast": { "$ref": "#/definitions/applyEndPatternLast" },
				"name": { "$ref": "#/definitions/name" },
				"contentName": { "$ref": "#/definitions/contentName" },
				"include": { "$ref": "#/definitions/include" },
				"patterns": { "$ref": "#/definitions/patterns" },
				"repository": { "$ref": "#/definitions/repository" },
				"disabled": { "$ref": "#/definitions/disabled" },
				"id": { "$ref": "#/definitions/id" },
				"comment": { "$ref": "#/definitions/comment" },
				"//": { "$ref": "#/definitions/commentSlash" }
			},
			"additionalProperties": { "description": "Unknown key" },
			"dependencies": {
				"match": {
					"properties": {
						"name": {
							"$ref": "#/definitions/name",
							"suggestSortText": "@name"
						},
						"begin": {
							"$ref": "#/definitions/begin",
							"suggestSortText": "~begin"
						},
						"end": {
							"$ref": "#/definitions/end",
							"suggestSortText": "~end"
						},
						"while": {
							"$ref": "#/definitions/while",
							"suggestSortText": "~while"
						},
						"beginCaptures": {
							"$ref": "#/definitions/beginCaptures",
							"suggestSortText": "~beginCaptures"
						},
						"endCaptures": {
							"$ref": "#/definitions/endCaptures",
							"suggestSortText": "~endCaptures"
						},
						"whileCaptures": {
							"$ref": "#/definitions/whileCaptures",
							"suggestSortText": "~whileCaptures"
						},
						"applyEndPatternLast": {
							"$ref": "#/definitions/applyEndPatternLast",
							"suggestSortText": "~applyEndPatternLast"
						},
						"patterns": {
							"$ref": "#/definitions/patterns",
							"suggestSortText": "~patterns"
						},
						"contentName": {
							"$ref": "#/definitions/contentName",
							"suggestSortText": "~contentName"
						},
						"include": {
							"$ref": "#/definitions/include",
							"suggestSortText": "~include"
						},
						"repository": {
							"$ref": "#/definitions/repository",
							"suggestSortText": "~repository"
						}
					}
				},
				"begin": {
					"properties": {
						"match": {
							"$ref": "#/definitions/match",
							"suggestSortText": "~match"
						},
						"beginCaptures": {
							"$ref": "#/definitions/beginCaptures",
							"suggestSortText": "@beginCaptures"
						},
						"patterns": {
							"$ref": "#/definitions/patterns",
							"suggestSortText": "@patterns"
						},
						"name": {
							"$ref": "#/definitions/name",
							"suggestSortText": "@name"
						},
						"contentName": {
							"$ref": "#/definitions/contentName",
							"suggestSortText": "@contentName"
						},
						"repository": {
							"$ref": "#/definitions/repository",
							"suggestSortText": "~repository"
						},
						"include": {
							"$ref": "#/definitions/include",
							"suggestSortText": "~include"
						}
					},
					"oneOf": [
						{
							"required": [ "end" ],
							"properties": {
								"end": {
									"$ref": "#/definitions/end",
									"suggestSortText": "!end"
								}
							}
						},
						{
							"required": [ "while" ],
							"properties": {
								"while": {
									"$ref": "#/definitions/while",
									"suggestSortText": "@while"
								}
							}
						}
					]
				},
				"while": {
					"required": [ "begin" ],
					"properties": {
						"match": {
							"$ref": "#/definitions/match",
							"suggestSortText": "~match"
						},
						"begin": {
							"$ref": "#/definitions/begin",
							"suggestSortText": "@begin"
						},
						"whileCaptures": {
							"$ref": "#/definitions/whileCaptures",
							"suggestSortText": "@whileCaptures"
						},
						"applyEndPatternLast": {
							"$ref": "#/definitions/applyEndPatternLast",
							"suggestSortText": "~applyEndPatternLast"
						},
						"end": {
							"$ref": "#/definitions/end",
							"suggestSortText": "~end"
						},
						"endCaptures": {
							"$ref": "#/definitions/endCaptures",
							"suggestSortText": "~endCaptures"
						},
						"include": {
							"$ref": "#/definitions/include",
							"suggestSortText": "~include"
						},
						"repository": {
							"$ref": "#/definitions/repository",
							"suggestSortText": "~repository"
						}
					}
				},
				"end": {
					"required": [ "begin" ],
					"properties": {
						"match": {
							"$ref": "#/definitions/match",
							"suggestSortText": "~match"
						},
						"begin": {
							"$ref": "#/definitions/begin",
							"suggestSortText": "!!begin"
						},
						"endCaptures": {
							"$ref": "#/definitions/endCaptures",
							"suggestSortText": "!endCaptures"
						},
						"applyEndPatternLast": {
							"$ref": "#/definitions/applyEndPatternLast",
							"suggestSortText": "@applyEndPatternLast"
						},
						"while": {
							"$ref": "#/definitions/while",
							"suggestSortText": "~while"
						},
						"whileCaptures": {
							"$ref": "#/definitions/whileCaptures",
							"suggestSortText": "~whileCaptures"
						},
						"include": {
							"$ref": "#/definitions/include",
							"suggestSortText": "~include"
						},
						"repository": {
							"$ref": "#/definitions/repository",
							"suggestSortText": "~repository"
						}
					}
				},
				"captures": {
					"if": { "required": [ "patterns" ] },
					"then": {
						"anyOf": [
							{
								"required": [ "begin" ],
								"properties": {
									"begin": {
										"$ref": "#/definitions/begin",
										"suggestSortText": "@begin"
									}
								}
							},
							{ "required": [ "end" ] },
							{ "required": [ "while" ] }
						]
					},
					"else": {
						"anyOf": [
							{
								"required": [ "match" ],
								"properties": {
									"match": {
										"$ref": "#/definitions/match",
										"suggestSortText": "@match"
									}
								}
							},
							{ "required": [ "begin" ] },
							{ "required": [ "end" ] },
							{ "required": [ "while" ] },
							{ "required": [ "beginCaptures" ] },
							{ "required": [ "endCaptures" ] },
							{ "required": [ "whileCaptures" ] },
							{ "required": [ "contentName" ] }
						]
					},
					"properties": {
						"include": {
							"$ref": "#/definitions/include",
							"suggestSortText": "~include"
						},
						"repository": {
							"$ref": "#/definitions/repository",
							"suggestSortText": "~repository"
						}
					}
				},
				"beginCaptures": {
					"required": [ "begin" ],
					"properties": {
						"match": {
							"$ref": "#/definitions/match",
							"suggestSortText": "~match"
						},
						"begin": {
							"$ref": "#/definitions/begin",
							"suggestSortText": "@begin"
						},
						"include": {
							"$ref": "#/definitions/include",
							"suggestSortText": "~include"
						},
						"repository": {
							"$ref": "#/definitions/repository",
							"suggestSortText": "~repository"
						}
					}
				},
				"whileCaptures": {
					"required": [
						"while",
						"begin"
					],
					"properties": {
						"match": {
							"$ref": "#/definitions/match",
							"suggestSortText": "~match"
						},
						"begin": {
							"$ref": "#/definitions/begin",
							"suggestSortText": "@begin"
						},
						"while": {
							"$ref": "#/definitions/while",
							"suggestSortText": "@while"
						},
						"end": {
							"$ref": "#/definitions/end",
							"suggestSortText": "~end"
						},
						"endCaptures": {
							"$ref": "#/definitions/endCaptures",
							"suggestSortText": "~endCaptures"
						},
						"include": {
							"$ref": "#/definitions/include",
							"suggestSortText": "~include"
						},
						"repository": {
							"$ref": "#/definitions/repository",
							"suggestSortText": "~repository"
						}
					}
				},
				"endCaptures": {
					"required": [
						"end",
						"begin"
					],
					"properties": {
						"match": {
							"$ref": "#/definitions/match",
							"suggestSortText": "~match"
						},
						"begin": {
							"$ref": "#/definitions/begin",
							"suggestSortText": "@begin"
						},
						"end": {
							"$ref": "#/definitions/end",
							"suggestSortText": "@end"
						},
						"while": {
							"$ref": "#/definitions/while",
							"suggestSortText": "~while"
						},
						"whileCaptures": {
							"$ref": "#/definitions/whileCaptures",
							"suggestSortText": "~whileCaptures"
						},
						"include": {
							"$ref": "#/definitions/include",
							"suggestSortText": "~include"
						},
						"repository": {
							"$ref": "#/definitions/repository",
							"suggestSortText": "~repository"
						}
					}
				},
				"applyEndPatternLast": {
					"required": [
						"begin",
						"end"
					],
					"properties": {
						"begin": {
							"$ref": "#/definitions/begin",
							"suggestSortText": "@begin"
						},
						"end": {
							"$ref": "#/definitions/end",
							"suggestSortText": "@end"
						},
						"while": {
							"$ref": "#/definitions/while",
							"suggestSortText": "~while"
						},
						"whileCaptures": {
							"$ref": "#/definitions/whileCaptures",
							"suggestSortText": "~whileCaptures"
						},
						"include": {
							"$ref": "#/definitions/include",
							"suggestSortText": "~include"
						},
						"repository": {
							"$ref": "#/definitions/repository",
							"suggestSortText": "~repository"
						}
					}
				},
				"contentName": {
					"required": [ "begin" ],
					"properties": {
						"begin": {
							"$ref": "#/definitions/begin",
							"suggestSortText": "@begin"
						},
						"match": {
							"$ref": "#/definitions/match",
							"suggestSortText": "~match"
						},
						"include": {
							"$ref": "#/definitions/include",
							"suggestSortText": "~include"
						},
						"repository": {
							"$ref": "#/definitions/repository",
							"suggestSortText": "~repository"
						}
					}
				},
				"repository": {
					"properties": {
						"match": {
							"$ref": "#/definitions/match",
							"suggestSortText": "~match"
						},
						"begin": {
							"$ref": "#/definitions/begin",
							"suggestSortText": "~begin"
						},
						"end": {
							"$ref": "#/definitions/end",
							"suggestSortText": "~end"
						},
						"while": {
							"$ref": "#/definitions/while",
							"suggestSortText": "~while"
						},
						"captures": {
							"$ref": "#/definitions/captures",
							"suggestSortText": "~captures"
						},
						"beginCaptures": {
							"$ref": "#/definitions/beginCaptures",
							"suggestSortText": "~beginCaptures"
						},
						"endCaptures": {
							"$ref": "#/definitions/endCaptures",
							"suggestSortText": "~endCaptures"
						},
						"whileCaptures": {
							"$ref": "#/definitions/whileCaptures",
							"suggestSortText": "~whileCaptures"
						},
						"applyEndPatternLast": {
							"$ref": "#/definitions/applyEndPatternLast",
							"suggestSortText": "~applyEndPatternLast"
						},
						"patterns": {
							"$ref": "#/definitions/patterns",
							"suggestSortText": "!patterns"
						},
						"name": {
							"$ref": "#/definitions/name",
							"suggestSortText": "~name"
						},
						"contentName": {
							"$ref": "#/definitions/contentName",
							"suggestSortText": "~contentName"
						}
					}
				}
			}
		},
		"match": {
			"$comment": "Having hovers over regex's is annoying. https://github.com/RedCMD/TmLanguage-Syntax-Highlighter/blob/main/src/Providers/HoverProvider.ts",
			"type": "string",
			"defaultSnippets": [
				{
					"label": "~Regular expression",
					"markdownDescription": "\t\"match\": \"\\\\b(true|false)\\\\b\"",
					"body": "${1:\\\\b(true|false)\\\\b}"
				}
			]
		},
		"begin": {
			"$comment": "Having hovers over regex's is annoying. https://github.com/RedCMD/TmLanguage-Syntax-Highlighter/blob/main/src/Providers/HoverProvider.ts",
			"type": "string",
			"defaultSnippets": [
				{
					"label": "Regular expression",
					"markdownDescription": "\t\"begin\": \"\\\"\"",
					"body": "${1:\"}"
				}
			]
		},
		"end": {
			"$comment": "Having hovers over regex's is annoying. https://github.com/RedCMD/TmLanguage-Syntax-Highlighter/blob/main/src/Providers/HoverProvider.ts",
			"type": "string",
			"defaultSnippets": [
				{
					"label": "Regular expression",
					"markdownDescription": "\t\"end\": \"\\\"\"",
					"body": "${1:\"}"
				}
			]
		},
		"while": {
			"$comment": "Having hovers over regex's is annoying. https://github.com/RedCMD/TmLanguage-Syntax-Highlighter/blob/main/src/Providers/HoverProvider.ts",
			"type": "string",
			"defaultSnippets": [
				{
					"label": "Regular expression",
					"markdownDescription": "\t\"while\": \"^\\\\s*\"",
					"body": "${1:^\\\\s*}"
				}
			]
		},
		"captures": {
			"$comment": "`\"markdownDescription\"` overrides `\"description\"`",
			"description": "Allows you to assign scopeNames/retokenize the captured text",
			"type": [
				"object",
				"array"
			],
			"patternProperties": { "^\\d+": { "$ref": "#/definitions/capture" } },
			"properties": {
				"comment": { "$ref": "#/definitions/comment" },
				"//": { "$ref": "#/definitions/commentSlash" },
				"0": { "$ref": "#/definitions/capture" }
			},
			"additionalProperties": {
				"description": "Unknown key. Use the format \"0\": { }",
				"markdownDescription": "Unknown key. Use the following format:\n\n\t\"0\": { }",
				"default": { }
			},
			"items": {
				"markdownDescription": "An array of `\"captures\"` is not officially supported by VSCode TextMate  \nBut still happens to work because JavaScript",
				"$ref": "#/definitions/capture"
			},
			"defaultSnippets": [
				{
					"label": "Capture 0",
					"markdownDescription": "\t\"0\": {\n\t\t\"name\": \"\"\n\t}",
					"body": { "${1:0}": { "name": "$2" } }
				}
			]
		},
		"capture": {
			"$comment": "Who knew all this could go inside a (capture)?",
			"description": "Target specific capture group",
			"type": "object",
			"properties": {
				"match": {
					"deprecationMessage": "Buggy. Nest inside \"patterns\" instead",
					"$ref": "#/definitions/match"
				},
				"begin": {
					"deprecationMessage": "Buggy. Nest inside \"patterns\" instead",
					"$ref": "#/definitions/begin"
				},
				"end": {
					"deprecationMessage": "Buggy. Nest inside \"patterns\" instead",
					"$ref": "#/definitions/end"
				},
				"while": {
					"deprecationMessage": "Buggy. Nest inside \"patterns\" instead",
					"$ref": "#/definitions/while"
				},
				"captures": {
					"deprecationMessage": "Buggy. Nest inside \"patterns\" instead",
					"$ref": "#/definitions/captures"
				},
				"beginCaptures": {
					"deprecationMessage": "Buggy. Nest inside \"patterns\" instead",
					"$ref": "#/definitions/beginCaptures"
				},
				"endCaptures": {
					"deprecationMessage": "Buggy. Nest inside \"patterns\" instead",
					"$ref": "#/definitions/endCaptures"
				},
				"whileCaptures": {
					"deprecationMessage": "Buggy. Nest inside \"patterns\" instead",
					"$ref": "#/definitions/whileCaptures"
				},
				"applyEndPatternLast": {
					"deprecationMessage": "Buggy. Nest inside \"patterns\" instead",
					"$ref": "#/definitions/applyEndPatternLast"
				},
				"name": {
					"$ref": "#/definitions/name",
					"suggestSortText": "@name"
				},
				"contentName": {
					"deprecationMessage": "Buggy. Use \"name\" instead",
					"$ref": "#/definitions/contentName"
				},
				"include": {
					"deprecationMessage": "\"patterns\" is required to be present here for \"include\" to work. But...\nConflict: \"patterns\" has higher priority than \"include\"",
					"default": "",
					"doNotSuggest": true
				},
				"patterns": {
					"$comment": "Change `false` to `true` to show a warning on \"patterns\" inside a (capture)",
					"if": false,
					"then": { "deprecationMessage": "A \"patterns\" array inside a (capture) causes a performance hit when at the end of a long line." },
					"else": { "description": "A \"patterns\" array inside a (capture) causes a performance hit when at the end of a long line." },
					"$ref": "#/definitions/patterns",
					"suggestSortText": "@patterns"
				},
				"repository": {
					"$ref": "#/definitions/repository",
					"suggestSortText": "@repository"
				},
				"disabled": {
					"$ref": "#/definitions/disabled",
					"doNotSuggest": true
				},
				"id": { "$ref": "#/definitions/id" },
				"comment": {
					"$ref": "#/definitions/comment",
					"suggestSortText": "_comment"
				},
				"//": { "$ref": "#/definitions/commentSlash" }
			},
			"dependencies": {
				"contentName": { "required": [ "patterns" ] },
				"match": { "required": [ "patterns" ] },
				"begin": { "required": [ "patterns" ] },
				"end": { "required": [ "patterns", "begin" ] },
				"while": { "required": [ "patterns", "begin" ] },
				"applyEndPatternLast": { "required": [ "patterns", "begin", "end" ] },
				"captures": {
					"required": [ "patterns" ],
					"anyOf": [
						{ "required": [ "match" ] },
						{ "required": [ "begin" ] },
						{ "required": [ "end" ] },
						{ "required": [ "while" ] }
					]
				},
				"beginCaptures": { "required": [ "patterns", "begin" ] },
				"endCaptures": { "required": [ "patterns", "begin", "end" ] },
				"whileCaptures": { "required": [ "patterns", "begin", "while" ] },
				"repository": {
					"required": [ "patterns" ],
					"properties": {
						"patterns": {
							"$ref": "#/definitions/patterns",
							"suggestSortText": "!patterns"
						}
					}
				}
			}
		},
		"beginCaptures": {
			"markdownDescription": "Allows you to assign `scopeNames`/retokenize the captured text  \nOnly applies to `\"begin\"`  \nOverrides `\"captures\"`",
			"$ref": "#/definitions/captures"
		},
		"endCaptures": {
			"markdownDescription": "Allows you to assign `scopeNames`/retokenize the captured text  \nOnly applies to `\"end\"`  \nOverrides `\"captures\"`",
			"$ref": "#/definitions/captures"
		},
		"whileCaptures": {
			"markdownDescription": "Allows you to assign `scopeNames`/retokenize the captured text  \nOnly applies to `\"while\"`  \nOverrides `\"captures\"`",
			"$ref": "#/definitions/captures"
		},
		"applyEndPatternLast": {
			"markdownDescription": "Controls if the `\"end\"` pattern should attempt to match before or after the `\"patterns\"` array  \n`0`, `false` and `null` will disable it. `true` and numbers != `0` will enable it",
			"type": [
				"boolean",
				"integer",
				"null"
			],
			"default": 1
		},
		"include": {
			"description": "Reference an item in a repository",
			"type": "string",
			"pattern": "^[\\w.#$-]*$",
			"defaultSnippets": [
				{
					"label": "#repo-item",
					"markdownDescription": "\t\"include\": \"#repo-item\"",
					"body": "#${1:repo-item}"
				}
			]
		},
		"name": {
			"description": "A list of space-separated scope-names to be assigned to the provided token. VSCode will then colour that token using the current theme\n`comment`, `string` and `regex` disables bracket matching while `meta.embedded` reenables it\nhttps://macromates.com/manual/en/language_grammars#naming_conventions",
			"$ref": "#/definitions/name-content"
		},
		"contentName": {
			"markdownDescription": "Same as `\"name\"`, but only applies to inside a `\"begin\"` - `\"end\"`/`\"while\"` region",
			"$ref": "#/definitions/name-content"
		},
		"name-content": {
			"type": "string",
			"anyOf": [
				{ "pattern": "^([\\w\\-. ]|\\$0*\\d{1,3}(?!\\d)|\\${0*\\d{1,3}:/(upcase|downcase)})*$" },
				{
					"$comment": "https://macromates.com/manual/en/language_grammars#naming_conventions",
					"enum": [
						"comment",
						"comment.line",
						"comment.line.double-slash",
						"comment.line.double-dash",
						"comment.line.number-sign",
						"comment.line.percentage",
						"comment.line.character",
						"comment.block",
						"comment.block.documentation",
						"constant",
						"constant.numeric",
						"constant.character",
						"constant.character.escape",
						"constant.language",
						"constant.other",
						"entity",
						"entity.name",
						"entity.name.function",
						"entity.name.type",
						"entity.name.tag",
						"entity.name.section",
						"entity.other",
						"entity.other.inherited-class",
						"entity.other.attribute-name",
						"invalid",
						"invalid.illegal",
						"invalid.deprecated",
						"keyword",
						"keyword.control",
						"keyword.operator",
						"keyword.other",
						"markup",
						"markup.underline",
						"markup.underline.link",
						"markup.bold",
						"markup.heading",
						"markup.italic",
						"markup.list",
						"markup.list.numbered",
						"markup.list.unnumbered",
						"markup.quote",
						"markup.raw",
						"markup.other",
						"meta",
						"storage",
						"storage.type",
						"storage.modifier",
						"string",
						"string.quoted",
						"string.quoted.single",
						"string.quoted.double",
						"string.quoted.triple",
						"string.quoted.other",
						"string.unquoted",
						"string.interpolated",
						"string.regexp",
						"string.other",
						"support",
						"support.function",
						"support.class",
						"support.type",
						"support.constant",
						"support.variable",
						"support.other",
						"variable",
						"variable.parameter",
						"variable.language",
						"variable.other"
					],
					"enumDescriptions": [
						"For comments",
						"Line comments, we specialize further so that the type of comment start character(s) can be extracted from the scope",
						"// comment",
						"-- comment",
						"# comment",
						"% comment",
						"Other types of line comments",
						"Multi-line comments like /* … */ and <!-- … -->",
						"Embedded documentation",
						"Various forms of constants",
						"Those which represent numbers, e.g. 42, 1.3f, 0x4AB1U",
						"Those which represent characters, e.g. &lt;, \\e, \\031",
						"Escape sequences like \\e would be constant.character.escape",
						"Constants (generally) provided by the language which are “special” like true, false, nil, YES, NO, etc",
						"Other constants, e.g. colors in CSS",
						"An entity refers to a larger part of the document, for example a chapter, class, function, or tag. We do not scope the entire entity as entity.* (we use meta.* for that). But we do use entity.* for the “placeholders” in the larger entity, e.g. if the entity is a chapter, we would use entity.name.section for the chapter title",
						"We are naming the larger entity",
						"The name of a function",
						"The name of a type declaration or class",
						"A tag name",
						"The name is the name of a section/heading",
						"Other entities",
						"The superclass/baseclass name",
						"The name of an attribute (mainly in tags)",
						"Stuff which is “invalid”",
						"Illegal, e.g. an ampersand or lower-than character in HTML (which is not part of an entity/tag)",
						"For deprecated stuff e.g. using an API function which is deprecated or using styling with strict HTML",
						"Keywords (when these do not fall into the other groups)",
						"Mainly related to flow control like continue, while, return, etc",
						"Operators can either be textual (e.g. or) or be characters",
						"Other keywords",
						"This is for markup languages and generally applies to larger subsets of the text",
						"Underlined text",
						"This is for links, as a convenience this is derived from markup.underline so that if there is no theme rule which specifically targets markup.underline.link then it will inherit the underline style",
						"Bold text (text which is strong and similar should preferably be derived from this name)",
						"A section header. Optionally provide the heading level as the next element, for example markup.heading.2.html for <h2>…</h2> in HTML",
						"Italic text (text which is emphasized and similar should preferably be derived from this name)",
						"List items",
						"Numbered list items",
						"Unnumbered list items",
						"Quoted (sometimes block quoted) text",
						"Text which is verbatim, e.g. code listings. Normally spell checking is disabled for markup.raw",
						"Other markup constructs",
						"The meta scope is generally used to markup larger parts of the document. For example the entire line which declares a function would be meta.function and the subsets would be storage.type, entity.name.function, variable.parameter etc. and only the latter would be styled. Sometimes the meta part of the scope will be used only to limit the more general element that is styled, most of the time meta scopes are however used in scope selectors for activation of bundle items. For example in Objective-C there is a meta scope for the interface declaration of a class and the implementation, allowing the same tab-triggers to expand differently, depending on context",
						"Things relating to “storage”",
						"The type of something, class, function, int, var, etc",
						"A storage modifier like static, final, abstract, etc",
						"Strings",
						"Quoted strings",
						"Single quoted strings: 'foo'",
						"Double quoted strings: \"foo\"",
						"Triple quoted strings: \"\"\"Python\"\"\"",
						"Other types of quoting: $'shell', %s{...}",
						"For things like here-docs and here-strings",
						"Strings which are “evaluated”: `date`, $(pwd)",
						"Regular expressions: /(\\w+)/",
						"Other types of strings (should rarely be used)",
						"Things provided by a framework or library should be below support",
						"Functions provided by the framework/library. For example NSLog in Objective-C is support.function",
						"When the framework/library provides classes",
						"Types provided by the framework/library, this is probably only used for languages derived from C, which has typedef (and struct). Most other languages would introduce new types as classes",
						"Constants (magic values) provided by the framework/library",
						"Variables provided by the framework/library. For example NSApp in AppKit",
						"The above should be exhaustive, but for everything else use support.other",
						"Variables. Not all languages allow easy identification (and thus markup) of these",
						"When the variable is declared as the parameter",
						"Reserved language variables like this, super, self, etc",
						"Other variables, like $some_variables"
					]
				}
			]
		},
		"injectionSelector": {
			"type": [
				"string",
				"array"
			],
			"items": {
				"markdownDescription": "An array of `\"injectionSelector\"` is not officially supported by VSCode TextMate  \nBut still happens to work because JavaScript",
				"$ref": "#/definitions/injectionSelector"
			},
			"default": "L:source.js -string -comment"
		},
		"disabled": {
			"markdownDescription": "Disables the current rule for easy testing  \n_Not currently supported by VSCode_",
			"type": [
				"integer",
				"boolean"
			],
			"suggestSortText": "~disabled",
			"default": 1
		},
		"id": {
			"deprecationMessage": "Used internally by the VSCode TextMate engine. Do Not Use",
			"doNotSuggest": true
		},
		"comment": {
			"$comment": "No description; because having hovers is annoying",
			"type": "string",
			"default": ""
		},
		"commentSlash": {
			"description": "Alternative comment; because VSCode ignores duplicate `//` keys. Supports all json types",
			"type": [
				"string",
				"object",
				"array",
				"integer",
				"number",
				"boolean",
				"null"
			],
			"suggestSortText": "~//",
			"default": ""
		}
	}
}
