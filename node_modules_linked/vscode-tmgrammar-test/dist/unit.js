#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const chalk_1 = __importDefault(require("chalk"));
const commander_1 = require("commander");
const glob_1 = __importDefault(require("glob"));
const bottleneck_1 = __importDefault(require("bottleneck"));
const index_1 = require("./unit/index");
const reporter_1 = require("./unit/reporter");
const index_2 = require("./common/index");
let packageJson = require('../package.json');
function collectGrammarOpts(value, previous) {
    return previous.concat([value]);
}
commander_1.program
    .description('Run Textmate grammar test cases using vscode-textmate')
    .option('-g, --grammar <grammar>', "Path to a grammar file. Multiple options supported. 'scopeName' is taken from the grammar", collectGrammarOpts, [])
    .option('--config <configuration.json>', 'Path to the language configuration, package.json by default')
    .option('-c, --compact', 'Display output in the compact format, which is easier to use with VSCode problem matchers')
    .option('--xunit-report <report.xml>', 'Path to directory where test reports in the XUnit format will be emitted in addition to console output')
    .option('--xunit-format <generic|gitlab>', 'Format of XML reports generated when --xunit-report is used. `gitlab` format is suitable for viewing the results in GitLab CI/CD web GUI')
    .version(packageJson.version)
    .argument('<testcases...>', 'A glob pattern(s) which specifies testcases to run, e.g. "./tests/**/test*.dhall". Quotes are important!')
    .parse(process.argv);
const options = commander_1.program.opts();
const TestFailed = -1;
const TestSuccessful = 0;
let { grammars } = (0, index_2.loadConfiguration)(options.config, options.scope, options.grammar);
const registry = (0, index_2.createRegistry)(grammars);
if (options.validate) {
    if (!!registry && typeof registry === 'object') {
        process.exit(0);
    }
    else {
        process.exit(1);
    }
}
const consoleReporter = options.compact ? new reporter_1.ConsoleCompactReporter() : new reporter_1.ConsoleFullReporter();
const reporter = options.xunitReport
    ? new reporter_1.CompositeReporter(consoleReporter, options.xunitFormat === 'gitlab'
        ? new reporter_1.XunitGitlabReporter(options.xunitReport)
        : new reporter_1.XunitGenericReporter(options.xunitReport))
    : consoleReporter;
const rawTestCases = commander_1.program.args.map((x) => glob_1.default.sync(x)).flat();
if (rawTestCases.length === 0) {
    console.log(chalk_1.default.red('ERROR') + ' no test cases found');
    process.exit(-1);
}
const limiter = new bottleneck_1.default({
    maxConcurrent: 8,
    minTime: 0
});
const testResults = Promise.all(rawTestCases.map((filename) => {
    let tc = undefined;
    try {
        tc = (0, index_1.parseGrammarTestCase)(fs.readFileSync(filename).toString());
    }
    catch (error) {
        reporter.reportParseError(filename, error);
        return new Promise((resolve, reject) => {
            resolve(TestFailed);
        });
    }
    let testCase = tc;
    return limiter
        .schedule(() => (0, index_1.runGrammarTestCase)(registry, testCase))
        .then((failures) => {
        reporter.reportTestResult(filename, testCase, failures);
        return failures.length === 0 ? TestSuccessful : TestFailed;
    })
        .catch((error) => {
        reporter.reportGrammarTestError(filename, testCase, error);
        return TestFailed;
    });
}));
testResults.then((xs) => {
    reporter.reportSuiteResult();
    const result = xs.reduce((a, b) => a + b, 0);
    if (result === TestSuccessful) {
        process.exit(0);
    }
    else {
        process.exit(-1);
    }
});
//# sourceMappingURL=unit.js.map